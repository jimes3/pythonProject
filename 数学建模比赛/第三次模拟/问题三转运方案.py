import numpy as np
import pandas as pd
from numpy import random
from copy import deepcopy
import matplotlib.pyplot as plt
np.set_printoptions(threshold=np.inf)
np.set_printoptions(suppress=True)
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
pd.set_option('max_colwidth',100)
plt.rcParams['axes.unicode_minus'] = False
plt.rcParams['font.family'] = ['sans-serif']
plt.rcParams['font.sans-serif'] = ['SimHei']
c = [[   0., 4075.,   72.,  499., 1255.,  446.,  933., 1732., 1426.,41., 0., 1902., 1666.,   10.,  779.,  335.,  203.,   59.,140.,   29., 1052.,  292.,   85.,  184.,  102.,  186.,  227.,19.,    0.,    2.,    3.,   23.,   90.],
     [   0., 3753., 1411., 1875., 2174.,  173., 1097., 1062.,  294.,18.,   62., 1393., 1175.,    0.,  962.,   10.,    0.,   22.,71.,  292., 1125.,  203.,  102.,   76.,    0.,    0.,   24.,105.,    6.,    7.,    1.,   19.,   86.],
     [   0., 4069.,  986., 1058.,  989.,  898., 1637., 1968.,  537.,13.,  228., 1900.,   90.,    0., 1430.,   19.,    2.,  244.,15.,   67.,  436.,  232.,   21.,  129.,  581.,    1.,   58., 90.,    6.,    4.,   15.,   30.,   91.],
     [   1., 4062.,  990.,  837., 2152.,  392.,  734., 1968.,   53.,1250.,  217., 1606.,  290.,   15., 1454.,   54.,   18.,  169.,132.,    9.,  373.,  101.,   24.,   16.,  171.,   83.,   94.,103.,    2.,    9.,    3.,  106.,   80.],
     [   0., 4075., 1126.,  502., 2156.,  820., 2158., 1970.,  238.,0.,  226., 1900.,  218.,    0.,  250.,    3.,    1.,  137.,6.,   64.,  758.,  209.,   58.,  158.,  267.,  146.,  209.,3.,   12.,    2.,   41.,   65.,   15.],
     [   0., 4067., 2552.,  842., 2163.,   11.,  140., 1480.,  773.,4.,  534., 1904.,  121.,   25., 1352.,    5.,    0.,   98.,6.,  117.,  620.,  120.,   46.,   97.,  111.,   57.,  151.,10.,    2.,    8.,    0.,   45.,    4.],
     [   0., 4067.,  378., 1877., 1929.,  263.,  663., 1727.,  501.,203.,  449., 1667.,    0.,   20., 1341.,    7.,  140.,  198.,32.,  163.,  915.,  151.,   56.,  113.,  274.,  173.,  177.,66.,    4.,    0.,   70.,   78.,   78.],
     [   0., 4059., 2190.,  603., 1453.,   33., 1343.,  872., 1202.,38.,  355., 1900.,  254.,    3.,  797.,    1.,    5.,   68.,3.,  324., 1155.,  151.,   42.,  138.,  404.,   11.,   42.,51.,    6.,    6.,    6.,   51.,   77.],
     [   0., 4075.,  553., 1286., 2048., 1378.,  388.,  462.,  813.,73., 1224.,  740., 1488.,   15.,  480.,    0.,  198.,   68.,125.,  295., 1169.,   39.,   77.,  275.,  208.,  123.,  244.,61.,   12.,    3.,    1.,   68.,   66.],
     [   0., 4059.,    0., 2491., 1610.,   65., 1794., 1781.,  501.,0.,  231., 1806.,  145.,    4.,  786.,   17.,    7.,  387.,135.,   63.,  847.,  147.,   38.,   45.,  116.,  214.,   53.,11.,   14.,    7.,   10.,   96.,   51.],
     [  10., 4061.,  856.,  408., 1579.,    4., 1110., 1947.,  346.,148.,  522., 1896.,  546.,  149., 1120.,  353.,  699.,   89.,61.,  258.,  966.,  230.,   11.,   43.,   47.,   66.,  138.,43.,    6.,    8.,    3.,   41.,  106.],
     [   0., 4070.,   92.,  220., 1098., 1630.,  672., 1299.,  668.,3.,  869., 1904.,  884.,  114., 1254.,  372.,  117.,  260.,50.,  216., 1166.,  233.,   54.,   33.,    6.,   72.,   48.,40.,    0.,   14.,    4.,   97.,   17.],
     [   0., 3731., 1756.,  584., 1689.,  871., 1143., 1968.,  467.,43.,  415., 1224.,   17.,  102., 1365.,    4.,   35.,  278.,83.,  218.,  597.,  312.,   24.,  170.,  377.,   13.,  164.,96.,    8.,    8.,    2.,   66.,   61.],
     [  17., 4075.,  377.,  708., 2174.,  104., 1032., 1668.,   76.,95.,  527., 1891.,  505.,  100.,  983.,  140.,  408.,  104.,59.,  514.,  903.,  239.,   30.,  125.,   36.,   85.,  357.,96.,    9.,    9.,    1.,   62.,   11.],
     [  71., 4064.,  532.,  383., 2174.,  670.,   20., 1099., 1863.,93.,  912., 1768.,  152.,    2., 1296.,  294.,   12.,  236.,121.,  116.,  568.,  261.,   42.,   53.,  180.,   11.,  121.,14.,   21.,    8.,  511.,   99.,  146.],
     [   0., 4069., 1156., 1469., 2167.,    4.,  458.,  990.,  709.,19.,  833., 1904., 1145.,  143.,  577.,  315.,    0.,  134.,65.,  232.,  484.,  102.,   52.,   42.,  161.,   92.,   80.,70.,    9.,    2.,   17.,   10.,  145.],
     [   0., 4074.,  298., 1871., 2167.,  944., 1024., 1603.,  227.,166.,  794., 1082.,   86.,   11., 1028.,  148.,   41.,   64.,93.,   12.,  739.,  274.,   46.,   98.,   26.,  190.,  237.,71.,   13.,    3.,  222.,  106.,  121.],
     [   0., 4053.,    2.,    0., 1721.,  397., 1541., 1511., 1917.,123.,  700., 1902.,  612.,   13., 1301.,    4.,    0.,  143.,50.,   41.,  211.,  134.,   86.,  160.,  298.,  202.,   94.,52.,    9.,   11.,  121.,   48.,  113.],
     [   0., 4075.,  966.,  210., 1729.,  363., 1532., 1584.,  162.,292., 1390., 1903.,  657.,   10., 1373.,    0.,   34.,  160.,36.,  317.,  378.,   48.,   13.,    5.,   30.,   64.,  245.,62.,    1.,    8.,   27.,   37.,  146.],
     [   0., 4075.,  161., 2239., 2174.,  475., 1002., 1970.,    9.,2.,  803.,  647.,  397.,    0., 1442.,   47.,  223.,   67.,92.,  280.,  581.,  195.,    7.,  287.,   31.,   15.,   50.,10.,    4.,    8.,  120.,   29.,  118.],
     [   0., 4075.,  939., 1355., 1932.,  330.,  423., 1120., 1001.,2.,  349., 1288.,  370.,  457., 1441.,   21.,   90.,  167.,8.,  374.,  920.,  157.,   91.,   81.,  141.,  204.,  123.,55.,   15.,    3.,  296.,   73.,   40.],
     [   0., 4075.,  396., 1107., 2172., 1229., 1699., 1001.,  313.,0.,  425., 1420.,  521.,    1., 1456.,    1.,  257.,  240.,123.,  148.,  320.,  128.,  184.,   22.,  170.,   90.,   20.,11.,    3.,    9.,    4.,   18.,   32.],
     [   0., 4075.,  349., 1315., 1747.,  732.,  695., 1761., 1196.,309.,  710., 1509.,  428.,    1., 1000.,    0.,   44.,   66.,108.,   39.,  843.,  264.,   86.,   65.,    0.,  109.,  192.,82.,    5.,    3.,   21.,   51.,   52.],
     [  14., 4075.,  589., 2466., 1387.,  136.,  628., 1957.,   12.,301., 1556., 1439.,  199.,    1.,  225.,   21.,    7.,  316.,202.,   69., 1169.,  169.,   27.,  251.,    1.,   88.,   58.,4.,   17.,   11.,   64.,   19.,  128.]]
c = np.array(c).T
########################################  平均损耗率
data = pd.read_excel("附件2 近5年8家转运商的相关数据.xlsx",sheet_name = '运输损耗率（%）')
data = data.drop('转运商ID', axis=1)
data = np.array(data)
w = []
for i in range(8):
    av = np.mean(data[i])
    r = np.sum(data[i] == 0)
    w.append(round(av*240/(240-r),4))

s = np.zeros((1,33))
sub = np.array(s).ravel()  # 自变量下限
up = np.array(s+7.9999).ravel()  # 自变量上限,取得到
type = (s).ravel()    #-1是有理数，0是整数，1是0-1变量
def dd2(best_x, x):  #欧氏距离
    best_x = np.array(best_x)   #转化成numpy数组
    x = np.array(x)          #转化成numpy数组
    c = np.sum(pow(x - best_x, 2), axis=1)    #求方差，在行上的标准差
    d = pow(c, 0.5)   #标准差
    return d
def new_min(arr):  #求最小
    min_data = min(arr)   #找到最小值
    key = np.argmin(arr)  #找到最小值的索引
    return min_data, key
def type_x(xx,type,n):  #变量范围约束
    for v in range(n):
        if type[v] == -1:
            xx[v] = np.maximum(sub[v], xx[v])
            xx[v] = np.minimum(up[v], xx[v])
        elif type[v] == 0:
            xx[v] = np.maximum(sub[v], int(xx[v]))
            xx[v] = np.minimum(up[v], int(xx[v]))
        else:
            xx[v] = np.maximum(sub[v], random.randint(0,2))
            xx[v] = np.minimum(up[v], random.randint(0,2))
    return xx
def woa(sub,up,type,nums,det,w,k):
    def fun(X,w=w,k=k):  # 目标函数和约束条件
        x = X.flatten() #将X变为一维数组
        xx = np.zeros((33,8))
        for i in range(33):
            xx[i][int(x[i])] = 1
        f = 0
        f1 = 0
        for i in range(33):
            for j in range(8):
                f1 +=random.uniform(0.6,1.4)*w[j]/100*c[i][k]*xx[i][j]
        f += f1
        for j in range(8):
            locals()['ss'+ str(j+1)] = 0
            for i in range(33):
                locals()['ss'+ str(j+1)] += c[i][k]*xx[i][j]
            if locals()['ss'+ str(j+1)]-6000 <= 0:
                pass
            else:
                f += 10000000*(locals()['ss'+ str(j+1)]-6000)
        return f
    n = len(sub)  # 自变量个数
    num = nums * n  # 种群大小
    x = np.zeros([num, n])  #生成保存解的矩阵
    f = np.zeros(num)   #生成保存值的矩阵
    for s in range(num):      #随机生成初始解
        rand_data = np.random.uniform(0,1)
        x[s, :] = sub + (up - sub) * rand_data
        x[s, :] = type_x(x[s, :],type,n)
        f[s] = fun(x[s, :])
    best_f, a = new_min(f)  # 记录历史最优值
    best_x = x[a, :]  # 记录历史最优解
    trace = np.array([deepcopy(best_f)]) #记录初始最优值,以便后期添加最优值画图
    ############################ 改进的鲸鱼算法 ################################
    xx = np.zeros([num, n])
    ff = np.zeros(num)
    Mc = (up - sub) * 0.1  # 猎物行动最大范围
    for ii in range(det):      #设置迭代次数，进入迭代过程
        # 猎物躲避,蒙特卡洛模拟，并选择最佳的点作为下一逃跑点 #########！！！创新点
        d = dd2(best_x, x)  #记录当前解与最优解的距离
        d.sort()  #从小到大排序,d[0]恒为0
        z = np.exp(-d[1] / np.mean(Mc))  # 猎物急躁系数
        z = max(z, 0.1)     #决定最终系数
        yx = []  #初始化存储函数值
        dx = []  #初始化存储解
        random_rand = random.random(n) #0-1的随机数
        for i in range(30):    #蒙特卡洛模拟的次数
            m = [random.choice([-1, 1]) for _ in range(n)] #随机的-1和1
            asd = best_x + Mc * z * ((det-ii )/det) * random_rand * m   #最优解更新公式
            xd = type_x(asd,type,n)  #对自变量进行限制
            if i < 1:
                dx = deepcopy(xd)
            else:
                dx = np.vstack((dx,xd))   #存储每一次的解
            yx=np.hstack((yx,fun(xd)))    #存储每一次的值
        best_t, a = new_min(yx)  # 选择最佳逃跑点
        best_c = dx[a, :]   #最佳逃跑点
        if best_t < best_f:   #与鲸鱼算法得到的最优值对比
            best_f = best_t   #更新最优值
            best_x = best_c   #更新最优解
        ############################# 鲸鱼追捕 #################################
        w = (ii / det)**3   #自适应惯性权重!!!创新点
        a = (2 - 2*ii/det)*(1- w)  #a随迭代次数从2非线性下降至0！！！创新点
        pp=0.7 if ii <= 0.5*det else 0.4
        for i in range(num):
            r1 = np.random.rand()  # r1为[0,1]之间的随机数
            r2 = np.random.rand()  # r2为[0,1]之间的随机数
            A = 2 * a * r1 - a
            C = 2 * r2
            b = 1     #螺旋形状系数
            l = np.random.uniform(-1,1)  #参数l
            p = np.random.rand()
            if p < pp:
                if abs(A) >= 1:
                    rand_leader = np.random.randint(0, num)
                    X_rand = x[rand_leader, :]
                    D_X_rand = abs(C * X_rand - x[i, :])
                    xx[i, :] = w*X_rand - A * D_X_rand
                    xx[i, :] = type_x(xx[i, :],type,n) #对自变量进行限制
                elif abs(A) < 1:
                    D_Leader = abs(C * best_x - x[i, :])
                    xx[i, :] = w*best_x - A * D_Leader
                    xx[i, :] = type_x(xx[i, :],type,n) #对自变量进行限制
            elif p >= pp:
                D = abs(best_x - x[i, :])
                xx[i, :] = D*np.exp(b*l)*np.cos(2*np.pi*l) + (1-w)*best_x   #完整的气泡网捕食公式
                xx[i, :] = type_x(xx[i, :],type,n) #对自变量进行限制
            ff[i] = fun(xx[i, :])
            if len(np.unique(ff[:i]))/(i+1) <= 0.1:     #limit阈值 + 随机差分变异！！！创新点
                xx[i,:] = (r1*(best_x-xx[i,:]) +
                           r2*(x[np.random.randint(0,num),:] - xx[i,:]))
                xx[i, :] = type_x(xx[i, :],type,n) #对自变量进行限制
                ff[i] = fun(xx[i, :])
        #将上一代种群与这一代种群以及最优种群结合，选取排名靠前的个体组成新的种群
        F = np.hstack((np.array([best_f]), f, ff))
        F, b = np.sort(F,axis=-1,kind='stable'), np.argsort(F)#按小到大排序,获得靠前的位置
        X = np.vstack(([best_x], x, xx))[b, :]
        f = F[:num]  #新种群的位置
        x = X[:num, :]  #新种群的位置
        best_f, a = new_min(f)  # 记录历史最优值
        best_x = x[a , :]  # 记录历史最优解
        trace = np.hstack((trace, [best_f]))
        #if ii % 10 == 0:
            #print('迭代次数：',ii)
    return best_x,best_f,trace

result = []
f = []
for i in range(24):
    best_x,best_f,trace = woa(sub,up,type,10,50,w,i)
    result.append(np.floor(best_x)+1)
    f.append(best_f/28200)
print(result)
print(f)

plt.plot([i for i in range(len(f))],f,label='原料损耗量')
plt.legend()
plt.show()
