import numpy as np
import pandas as pd
from numpy import random
from copy import deepcopy
import matplotlib.pyplot as plt
np.set_printoptions(threshold=np.inf)
np.set_printoptions(suppress=True)
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
pd.set_option('max_colwidth',100)
plt.rcParams['axes.unicode_minus'] = False
plt.rcParams['font.family'] = ['sans-serif']
plt.rcParams['font.sans-serif'] = ['SimHei']
c = [[2000., 1851., 1461., 1539.,  545.,  567.,  807.,  537.,  860.,534.,  775.,  993., 1104.,  703.,  499.,  635.,  612.,  156.,70.,  228.,  632.,  144.,   83.,  121.,  484.,  130.,  164.,40.,    9.,    7.,  437.,   41.,   69.],
 [1999., 1973., 1154., 1041., 1078.,  687.,  795., 1008.,  881.,418.,  532.,  842.,  649.,  872.,  742.,  341.,  542.,  187.,70.,  164.,  581.,  227.,   62.,  166.,  556.,   94.,  165.,44.,   11.,    6.,  431.,   39.,   86.],
 [1129., 1821., 1947., 1044., 1059.,  830.,  860.,  914.,  787.,817.,  528.,  810.,  725.,  567.,  652.,  725.,  496.,  182.,72.,  230.,  396.,  173.,   70.,  107.,  505.,  123.,  135.,57.,   11.,    5.,  837.,   41.,   95.],
 [1860., 1328., 1875., 1085.,  687.,  772.,  855.,  892.,  812.,781.,  850.,  789.,  753.,  718.,  543.,  663.,  539.,  135.,88.,  178.,  446.,  238.,   74.,  122.,  482.,  142.,  129.,53.,   10.,    6.,  644.,   36.,   56.],
 [2257., 1775., 1331., 1042., 1136.,  503.,  952., 1018.,  339.,653.,  780.,  935.,  758.,  576.,  838.,  775.,  490.,  140.,66.,  174.,  622.,  140.,   45.,   93.,  429.,   57.,  137.,67.,    9.,    8.,  467.,   44.,   64.],
 [1708., 1879., 1533.,  905., 1253.,  361., 1268.,  725.,  935.,453.,  131.,  896.,  727.,  439.,  852.,  520.,  619.,  132.,151.,  300.,  513.,  140.,   82.,  193.,  437.,   88.,  273.,63.,    5.,    5.,  729.,   52.,   78.],
 [1911., 2223., 1734., 1095., 1128.,  548., 1003.,  573.,  656.,657.,  296.,  950.,  757.,  650.,  777.,  673.,  435.,  130.,83.,  207.,  410.,  107.,   64.,  131.,  298.,   96.,  135.,59.,   12.,    8.,  824.,   56.,   53.],
 [1242., 2126., 1454., 1773., 1011.,  441.,  523.,  624., 1074.,501.,  696.,  622.,  691.,  559.,  809., 1018.,  420.,  108.,67.,  224.,  585.,  211.,   79.,  127.,  402.,  140.,   89.,60.,   14.,    8.,  679.,   31.,   48.],
 [1523., 1675., 1350., 1456.,  983.,  414.,  468.,  997.,  409.,828., 1005., 1133.,  769.,  563.,  760.,  751.,  456.,  149.,85.,  135.,  656.,  251.,   98.,   86.,  506.,  128.,   98.,65.,   12.,    5.,  805.,   50.,   56.],
 [2536., 1608., 1104.,  928.,  920.,  824., 1126., 1122.,  793.,469.,  610.,  964.,  501.,  258.,  432.,  918.,  600.,  195.,88.,  202.,  355.,  231.,  119.,  127.,  434.,   84.,  210., 53.,    7.,    5.,  669.,   42.,   43.],
 [1856., 1611., 1643., 1255.,  942.,  721.,  956.,  778., 1043.,630.,  710.,  742.,  770.,  850.,  491.,  478.,  471.,  192.,100.,  252.,  437.,  211.,   79.,   94.,  431.,  104.,  149.,44.,    9.,    6.,  687.,   48.,   67.],
 [1736., 1594., 1308.,  509.,  750., 1072., 1118.,  826.,  579.,353.,  581., 1151.,  768.,  664.,  791.,  671.,  479.,  228.,113.,  242.,  605.,  255.,  104.,  166.,  631.,  155.,  114.,41.,    8.,    8.,  762.,   45.,   74.],
 [1846., 1607.,  910., 1517.,  816., 1024.,  993.,  876.,  655.,803.,  742.,  772.,  624.,  838.,  481.,  549.,  645.,  164.,115.,  259.,  489.,  241.,  100.,  116.,  518.,  112.,  160.,65.,    9.,    7.,  743.,   53.,   51.],
 [1876., 1256., 1319., 1130.,  552.,  877., 1212.,  662.,  797.,765.,  872., 1056.,  939.,  565.,  778.,  491.,  569.,  174.,72.,  184.,  478.,  231.,   77.,  140.,  539.,  147.,  173.,72.,    9.,    8.,  450.,   39.,   68.],
 [1983., 1410., 1200., 1116.,  979.,  709., 1278., 1033.,  735.,571.,  507., 1046.,  915.,  793.,  608.,  684.,  476.,  186.,110.,  195.,  430.,  173.,   76.,  108.,  394.,   97.,  146.,39.,    8.,    4.,  739.,   41.,   38.],
 [1836., 2061., 1179., 1539.,  907.,  832.,  937.,  700.,  406.,643.,  549.,  659.,  993.,  723.,  644.,  529.,  314.,  148.,121.,  217.,  480.,  212.,   44.,  122.,  675.,   64.,  187.,38.,    7.,    7.,  674.,   21.,   57.],
 [1880., 1941., 1384., 1188.,  771.,  581.,  856.,  698.,  638.,573.,  670.,  898.,  778.,  935.,  604.,  641.,  446.,  141.,110.,  283.,  719.,   90.,  102.,   95.,  802.,   94.,   66.,59.,   10.,    7.,  654.,   76.,   60.],
 [1305., 1850., 1913.,  626.,  853.,  673.,  946.,  930.,  968.,812.,  677.,  859.,  543.,  733.,  440.,  760.,  711.,  109.,117.,  231.,  298.,  225.,   80.,   77.,  555.,  119.,  177.,66.,   11.,    7.,  777.,   54.,   62.],
 [1403., 1012., 1643., 1674., 1057.,  498.,  899.,  655.,  689.,773.,  696., 1109.,  884.,  783.,  666.,  596.,  401.,  171.,87.,  199.,  681.,  352.,   69.,  147.,  414.,  125.,  112.,51.,    7.,    7.,  854.,   52.,   64.],
 [1542., 2300., 1458.,  988.,  757.,  974.,  890.,  883.,  663.,579.,  617.,  660., 1028.,  628.,  569.,  560.,  499.,  171.,82.,  182.,  463.,  189.,   97.,  103.,  496.,  124.,  145.,48.,    8.,    6.,  652.,   36.,   64.],
 [1982., 1723., 1430., 1251.,  971.,  648.,  822.,  806.,  689.,714.,  658.,  825.,  813.,  587.,  704.,  644.,  620.,  169.,80.,  207.,  482.,  204.,   80.,  116.,  490.,  102.,  166.,45.,    9.,    6.,  676.,   52.,   74.],
 [1803., 1995., 1059.,  983.,  905.,  516., 1034.,  559.,  902.,598.,  849., 1147.,  771.,  588.,  474.,  739.,  606.,  142.,104.,  241.,  469.,  252.,   74.,  134.,  489.,   82.,  169.,45.,    7.,    4.,  665.,   48.,   60.],
 [1857., 1494., 1758.,  989., 1238.,  508.,  927.,  689.,  691.,494.,  858.,  930.,  805.,  610.,  523.,  832.,  518.,  111.,101.,  217.,  526.,  155.,  109.,  122.,  619.,  141.,  186.,49.,    9.,    8.,  657.,   49.,   75.],
 [1534., 2171., 1638.,  813.,  971.,  630.,  617.,  786.,  630.,656.,  746.,  755.,  861.,  566.,  706.,  689.,  649.,  127.,66.,  280.,  572.,  190.,   90.,  135.,  449.,  127.,  107.,56.,    9.,    7.,  713.,   51.,   50.]]
c = np.array(c).T
########################################  平均损耗率
data = pd.read_excel("附件2 近5年8家转运商的相关数据.xlsx",sheet_name = '运输损耗率（%）')
data = data.drop('转运商ID', axis=1)
data = np.array(data)
w = []
for i in range(8):
    av = np.mean(data[i])
    r = np.sum(data[i] == 0)
    w.append(round(av*240/(240-r),4))

s = np.zeros((1,33))
sub = np.array(s).ravel()  # 自变量下限
up = np.array(s+7.9999).ravel()  # 自变量上限,取得到
type = (s).ravel()    #-1是有理数，0是整数，1是0-1变量
def dd2(best_x, x):  #欧氏距离
    best_x = np.array(best_x)   #转化成numpy数组
    x = np.array(x)          #转化成numpy数组
    c = np.sum(pow(x - best_x, 2), axis=1)    #求方差，在行上的标准差
    d = pow(c, 0.5)   #标准差
    return d
def new_min(arr):  #求最小
    min_data = min(arr)   #找到最小值
    key = np.argmin(arr)  #找到最小值的索引
    return min_data, key
def type_x(xx,type,n):  #变量范围约束
    for v in range(n):
        if type[v] == -1:
            xx[v] = np.maximum(sub[v], xx[v])
            xx[v] = np.minimum(up[v], xx[v])
        elif type[v] == 0:
            xx[v] = np.maximum(sub[v], int(xx[v]))
            xx[v] = np.minimum(up[v], int(xx[v]))
        else:
            xx[v] = np.maximum(sub[v], random.randint(0,2))
            xx[v] = np.minimum(up[v], random.randint(0,2))
    return xx
def woa(sub,up,type,nums,det,w):
    def fun(X,w=w):  # 目标函数和约束条件
        x = X.flatten() #将X变为一维数组
        xx = np.zeros((33,8))
        for i in range(33):
            xx[i][int(x[i])] = 1
        f = 0
        f1 = 0
        for i in range(33):
            for j in range(8):
                f1 +=random.uniform(0.6,1.4)*w[j]/100*c[i][0]*xx[i][j]
        f += f1
        for j in range(8):
            locals()['ss'+ str(j+1)] = 0
            for i in range(33):
                locals()['ss'+ str(j+1)] += c[i][0]*xx[i][j]
            if locals()['ss'+ str(j+1)]-6000 <= 0:
                pass
            else:
                f += 10000000*(locals()['ss'+ str(j+1)]-6000)
        return f
    n = len(sub)  # 自变量个数
    num = nums * n  # 种群大小
    x = np.zeros([num, n])  #生成保存解的矩阵
    f = np.zeros(num)   #生成保存值的矩阵
    for s in range(num):      #随机生成初始解
        rand_data = np.random.uniform(0,1)
        x[s, :] = sub + (up - sub) * rand_data
        x[s, :] = type_x(x[s, :],type,n)
        f[s] = fun(x[s, :])
    best_f, a = new_min(f)  # 记录历史最优值
    best_x = x[a, :]  # 记录历史最优解
    trace = np.array([deepcopy(best_f)]) #记录初始最优值,以便后期添加最优值画图
    ############################ 改进的鲸鱼算法 ################################
    xx = np.zeros([num, n])
    ff = np.zeros(num)
    Mc = (up - sub) * 0.1  # 猎物行动最大范围
    for ii in range(det):      #设置迭代次数，进入迭代过程
        # 猎物躲避,蒙特卡洛模拟，并选择最佳的点作为下一逃跑点 #########！！！创新点
        d = dd2(best_x, x)  #记录当前解与最优解的距离
        d.sort()  #从小到大排序,d[0]恒为0
        z = np.exp(-d[1] / np.mean(Mc))  # 猎物急躁系数
        z = max(z, 0.1)     #决定最终系数
        yx = []  #初始化存储函数值
        dx = []  #初始化存储解
        random_rand = random.random(n) #0-1的随机数
        for i in range(30):    #蒙特卡洛模拟的次数
            m = [random.choice([-1, 1]) for _ in range(n)] #随机的-1和1
            asd = best_x + Mc * z * ((det-ii )/det) * random_rand * m   #最优解更新公式
            xd = type_x(asd,type,n)  #对自变量进行限制
            if i < 1:
                dx = deepcopy(xd)
            else:
                dx = np.vstack((dx,xd))   #存储每一次的解
            yx=np.hstack((yx,fun(xd)))    #存储每一次的值
        best_t, a = new_min(yx)  # 选择最佳逃跑点
        best_c = dx[a, :]   #最佳逃跑点
        if best_t < best_f:   #与鲸鱼算法得到的最优值对比
            best_f = best_t   #更新最优值
            best_x = best_c   #更新最优解
        ############################# 鲸鱼追捕 #################################
        w = (ii / det)**3   #自适应惯性权重!!!创新点
        a = (2 - 2*ii/det)*(1- w)  #a随迭代次数从2非线性下降至0！！！创新点
        pp=0.7 if ii <= 0.5*det else 0.4
        for i in range(num):
            r1 = np.random.rand()  # r1为[0,1]之间的随机数
            r2 = np.random.rand()  # r2为[0,1]之间的随机数
            A = 2 * a * r1 - a
            C = 2 * r2
            b = 1     #螺旋形状系数
            l = np.random.uniform(-1,1)  #参数l
            p = np.random.rand()
            if p < pp:
                if abs(A) >= 1:
                    rand_leader = np.random.randint(0, num)
                    X_rand = x[rand_leader, :]
                    D_X_rand = abs(C * X_rand - x[i, :])
                    xx[i, :] = w*X_rand - A * D_X_rand
                    xx[i, :] = type_x(xx[i, :],type,n) #对自变量进行限制
                elif abs(A) < 1:
                    D_Leader = abs(C * best_x - x[i, :])
                    xx[i, :] = w*best_x - A * D_Leader
                    xx[i, :] = type_x(xx[i, :],type,n) #对自变量进行限制
            elif p >= pp:
                D = abs(best_x - x[i, :])
                xx[i, :] = D*np.exp(b*l)*np.cos(2*np.pi*l) + (1-w)*best_x   #完整的气泡网捕食公式
                xx[i, :] = type_x(xx[i, :],type,n) #对自变量进行限制
            ff[i] = fun(xx[i, :])
            if len(np.unique(ff[:i]))/(i+1) <= 0.1:     #limit阈值 + 随机差分变异！！！创新点
                xx[i,:] = (r1*(best_x-xx[i,:]) +
                           r2*(x[np.random.randint(0,num),:] - xx[i,:]))
                xx[i, :] = type_x(xx[i, :],type,n) #对自变量进行限制
                ff[i] = fun(xx[i, :])
        #将上一代种群与这一代种群以及最优种群结合，选取排名靠前的个体组成新的种群
        F = np.hstack((np.array([best_f]), f, ff))
        F, b = np.sort(F,axis=-1,kind='stable'), np.argsort(F)#按小到大排序,获得靠前的位置
        X = np.vstack(([best_x], x, xx))[b, :]
        f = F[:num]  #新种群的位置
        x = X[:num, :]  #新种群的位置
        best_f, a = new_min(f)  # 记录历史最优值
        best_x = x[a , :]  # 记录历史最优解
        trace = np.hstack((trace, [best_f]))
        #if ii % 10 == 0:
            #print('迭代次数：',ii)
    return best_x,best_f,trace

result = []
f = []
for i in range(24):
    best_x,best_f,trace = woa(sub,up,type,10,50,w)
    result.append(np.floor(best_x)+1)
    f.append(best_f/28200)
print(result)
print(f)

plt.plot([i for i in range(len(f))],f,label='原料损耗量')
plt.legend()
plt.show()
